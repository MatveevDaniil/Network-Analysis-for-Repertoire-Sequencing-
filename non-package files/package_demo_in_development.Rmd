---
title: "NAIR: Network Analysis of Immune Repertoire"
output:
  html_document:
    toc: yes
    toc_float: yes
    toc_depth: 2
    df_print: paged
---

The `NAIR` package facilitates network analysis of the adaptive immune repertoire based on similarities among the receptor sequences. It implements custom pipelines developed in the following paper:

Hai Yang, Jason Cham, Zenghua Fan, Brian Neal, Tao He and Li Zhang. "Network Analysis of Immune Repertoire (NAIR) with Advanced Machine Learning Techniques." In: Briefings in Bioinformatics (under review).


### What can `NAIR` do?

`NAIR` allows the user to:

* Perform general network analysis on immune repertoire sequence (RepSeq) data, including computing local and global network properties of nodes and clusters
* Search across multiple RepSeq samples for:
    * Clones/clusters associated to a clinical outcome
    * Public clones/clusters 
* Generate customized visualizations of the immune repertoire network
* Perform further downstream analysis


### What data does `NAIR` support?

`NAIR` supports bulk and single-cell immune repertoire sequence data for T-cell or B-cell receptors (TCR or BCR).

* **Single-cell data:** Each row is a single T-cell/B-cell
* **Bulk data:** Each row is a distinct TCR/BCR clone (unique combination of V-D-J genes and nucleotide sequence) and typically includes a corresponding measurement of clonal abundance (e.g., clone count and clone frequency/fraction)


### How does `NAIR` model the immune repertoire as a network?

* Each TCR/BCR cell (single-cell data) or clone (bulk data) is modeled as a node (vertex) in the network
* For each node, we consider the corresponding receptor sequence (nucleotide or amino acid)
* For each pair of nodes, we measure the similarity in their receptor sequences (using the Hamming or Levenshtein distance)
* An edge is drawn between two nodes if the distance is below a specified threshold 





# The `buildRepSeqNetwork()` function

General network analysis on RepSeq data is performed using the `buildRepSeqNetwork()` function. This function does the following:

* Builds the network graph for the immune repertoire
* Computes desired network properties
* Prints a customized `ggraph` plot of the network graph
* Returns meta-data for the TCR/BCR (nodes) in the network, including biological as well as network properties
* If desired for downstream analysis, can also return the network `igraph` and adjacency matrix, as well as the `ggraph` plot object


### Load Data

For demonstration purposes, we load a  [public data set](https://www.10xgenomics.com/resources/datasets/pbm-cs-of-a-healthy-donor-v-1-1-1-standard-3-1-0) hosted at 10xgenomics.com using Bioconductor.

```{r }
if (!require("BiocFileCache", quietly = TRUE)) { 
  if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
  }
  BiocManager::install("BiocFileCache", update = FALSE) 
}
library(NAIR)
library(BiocFileCache)
bfc <- BiocFileCache(ask = FALSE)
data_file <- bfcrpath(bfc, file.path(
  "http://cf.10xgenomics.com/samples/cell-vdj/3.1.0",
  "vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_t_filtered_contig_annotations.csv"))
tcr_data <- read.csv(data_file, stringsAsFactors = FALSE)
head(tcr_data)

# load data sets
# dir_main <-
#   dirname(dirname(rstudioapi::getActiveDocumentContext()$path))
# dir_data <- file.path(dir_main, "input_data")
# dir_out <- file.path(dir_data, "dummy_output")
# 
# data <- read.table(
#   file.path(dir_data, "TRB-Pt-10-2-500ng-15-04-2020-gDNA_S48.clones.txt"),
#   sep = '\t', header = TRUE)

```

Each row corresponds to a TCR sequence from a single cell, with the cell ID contained in the first column, `barcode`. Sequences from both the beta and alpha chains are present, as denoted by the values `TRA` and `TRB` in the column `chain`. We consider the beta-chain CDR3 amino acid sequences.

```{r}
# Subset rows for valid beta-chain CDR3 amino acid sequences
tcr_data <- tcr_data[tcr_data$chain == "TRB" & tcr_data$cdr3 != "None", ]

# Number of sequences/cells (rows)
nrow(tcr_data)

head(tcr_data)
```



## Basic Usage

Calling `buildRepSeqNetwork()` for our example is as simple as executing the following line of code:

```{r, eval = FALSE}
buildRepSeqNetwork(tcr_data, "cdr3")
```

* The first argument specifies the data frame containing the rep-seq data, where each row corresponds to a single TCR/BCR clone (bulk data) or cell (single-cell data).
* The second argument specifies the column name or number of the data frame that contains the receptor sequences to be used as the basis of similarity between two cells or clones.

Let's observe the effects and the output when we call the function using the default settings:

```{r, echo = FALSE}
output <- buildRepSeqNetwork(tcr_data, "cdr3")
```

The console messages indicate the following tasks being performed:

* The input data is filtered to remove rows with sequences below 3 characters in length
* The edges of the network graph are computed by calculating the Hamming distance between pairs of the receptor sequences in `tcr_data$cdr3`
* Isolated nodes (those not joined by an edge to any other node) are removed from the graph
* A plot of the network graph is generated

We examine the output returned by the function.
```{r}
typeof(output)
is.data.frame(output)
head(output)
```

The returned data frame contains the same variables as the input data. Only rows corresponding to nodes that remain in the network graph are included (those corresponding to the dropped isolated nodes have been removed):
```{r}
nrow(output)
```

Thus, this output data serves as biological meta-data for the nodes in the network graph, with each row corresponding to a node seen in the plot above.


## Network Properties

To include network properties in the output of `buildRepSeqNetwork()`, we use the `node_stats` and `cluster_stats` arguments; these respectively specify whether node-level and cluster-level properties are computed.
```{r}
# Node-level properties
output <- buildRepSeqNetwork(tcr_data, "cdr3",
                             node_stats = TRUE)
head(output)
```
The output data now contains node-level network properties in addition to the biological meta-data.

We also notice in the plot that nodes are now colored by network degree, which is one of the included node-level network properties.

Now let's repeat, this time including the cluster-level stats:

```{r}
# Node-level and cluster-level properties
output <- buildRepSeqNetwork(tcr_data, "cdr3",
                             node_stats = TRUE,
                             cluster_stats = TRUE)
```

The output is no longer a single data frame; instead, it is now a list which contains two data frames, one for the node-level meta data and one for the cluster-level meta data:

```{r}
# Output is a list
typeof(output)

# Output is not a data frame
is.data.frame(output)

# Output list contains the following items:
names(output)
```

```{r}
# View variables in the cluster-level meta data
head(output$cluster_stats)
```
Each row of the cluster-level meta data corresponds to a single cluster in the network.



## Customized Visualization

The network graph plot produced by `buildRepSeqNetwork()` can be customized in various ways.


### Color nodes using meta data

The nodes in the graph can be colored according to node-level meta-data by specifying a variable name in the `color_nodes_by` argument. This can be a variable from the input data or one of the node-level network properties included in the output.

For example, we can color the nodes based on the `transitivity` network property:
```{r}
output <- buildRepSeqNetwork(tcr_data, "cdr3",
                             node_stats = TRUE,
                             color_nodes_by = "transitivity")
```

### Adjust node color palette

The color palette used to color the nodes can be specified using the `color_scheme` argument. Options include:

* `"default"` for default `ggplot2` colors
* A viridis color map option (e.g., `"viridis"`, `"plasma"`, etc., or one the corresponding strings "A" through "H"; see `?viridis` for details). The direction of the color gradient can be reversed by appending `"-1"`, as in `"viridis-1"`.
* A palette from `grDevices::hcl.pals()` (these can only be used if the variable used to color the nodes is discrete).

```{r}
# Using the "plasma" color scheme with reversed color gradient
output <- buildRepSeqNetwork(tcr_data, "cdr3",
                             node_stats = TRUE,
                             color_nodes_by = "transitivity",
                             color_scheme = "plasma-1")
```

### Adjust node sizes or size nodes using meta data

The fixed size of the nodes can be adjusted by supplying a numeric value to the argument `size_nodes_by`. This argument also allows nodes to be sized dynamically based on node-level meta data by supplying a variable name, similarly to `color_nodes_by`. 