---
title: "Finding Associated Clones"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Finding Associated Clones}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center", 
  out.width = "100%",
  fig.width = 9, fig.height = 7
)
```


The `NAIR` package contains a set of functions that can be used to search across samples for TCR/BCR clones associated to a sample- or subject-level binary outcome/characteristic. 


### Load Data

For demonstration purposes, we simulate some toy data using built-in package functions.

```{r }
# Use temp dir
data_dir <- tempdir()

# Directory to store input files
dir_input_samples <- file.path(data_dir, "input_samples")
dir.create(dir_input_samples, showWarnings = FALSE)


library(NAIR)

samples <- 30
affixes <- c("AAAA", "AASA", "AACA", "AAQA", "AAQ", "AAA", "AASAA", "AAAAA")
affix_probs_g0 <- rep(1 / length(affixes), 
                      times = length(affixes) * samples / 2)
affix_probs_g1 <- rep(c(1, 5, 1, 1, 1, 1, 5, 1), times = samples / 2)
affix_probs <- matrix(c(affix_probs_g0, affix_probs_g1),
                      nrow = samples, byrow = TRUE)
new_probs_g0 <- rep(c(1/2, 1/6, 1/6, 1/6), times = samples / 2)
new_probs_g1 <- rep(c(1/3, 1/6, 1/6, 1/3), times = samples / 2)
new_probs <- matrix(c(new_probs_g0, new_probs_g1),
                    nrow = samples, byrow = TRUE)

simulateToyData(
  samples = samples,
  sample_size = 30,
  prefix_length = 1,
  prefix_chars = c("A", "C"),
  prefix_probs = cbind(rep(1, samples), rep(0, samples)),
  affixes = affixes,
  affix_probs = affix_probs,
  num_edits = 4,
  edit_pos_probs = function(seq_length) {
    dnorm(seq(-4, 4, length.out = seq_length))
  },
  edit_ops = c("insertion", "deletion", "transmutation"),
  edit_probs = c(5, 1, 4),
  new_chars = c("A", "S", "C", "Q"),
  new_probs = new_probs,
  output_dir = dir_input_samples,
  no_return = TRUE
)
```


## 1. Find Associated Sequences

The first step is to search across samples for associated sequences based on Fisher's exact test $P$-value using the `findAssociatedSeqs` function. The primary argument `file_list` accepts a character vector of file paths, each containing the RepSeq data for an individual sample.

When we simulated our data, 30 samples were created as individual data frames, with each saved to a separate file using the .rds file format. We create the vector of file paths for these input files below:

```{r}
# input files for step 1 (one per sample)
input_files <- file.path(dir_input_samples, paste0("Sample", 1:samples, ".rds"))
head(input_files)
```

When calling `findAssociatedSeqs()`, we specify the file format of our input files using `input_type = "rds"`; other supported formats include rda, csv, and files that can be read using `read.table()`, such as tsv and txt files.

The `group_ids` argument is used to assign each sample to one of the two binary outcome groups. The argument takes a character vector of the same length as `file_list`, where each value is the group label/ID for the corresponding sample. Any values may be used for the group labels, as long as the vector contains exactly two unique values.

In our simulated data, the first half of the samples correspond to the reference group, while the last half correspond to the comparison group:

```{r}
# group labels for the samples
group_labels <- c(rep("reference", samples / 2), rep("comparison", samples / 2))
```

The `groups` argument is used to specify which of the two group ID values denotes the reference group and which value denotes the comparison group. The argument takes a character vector of length 2, where the first and second elements always correspond to the reference and comparison groups, respectively.

The `subject_ids` argument can be used to assign each sample to a particular subject in a manner similar to the `group_ids` argument. If not provided, each sample is treated as coming from a distinct subject when conducting the Fisher's exact tests.

The `sample_ids` argument can be used to assign custom sample IDs; by default, the samples are labeled numerically according to the order they appear in `file_list`.

```{r}
# search across samples for associated sequences using Fisher's exact test
associated_seqs <- findAssociatedSeqs(
  file_list = input_files, input_type = "rds", 
  group_ids = group_labels, groups = c("reference", "comparison"), 
  min_seq_length = NULL, drop_matches = NULL,
  seq_col = "CloneSeq", outfile = NULL)
```

The filtering settings can be adjusted using the arguments seen below, which are shown with their default values:

```{r, eval = FALSE}
associated_seqs <- findAssociatedSeqs(
  file_list = input_files, input_type = "rds", 
  group_ids = group_labels, groups = c("reference", "comparison"), 
  min_seq_length = 7, drop_matches = "[*|_]",
  min_sample_membership = 5, pval_cutoff = 0.05,
  seq_col = "CloneSeq")
```

The function returns a data frame containing the filtered sequences ranked by Fisher's exact test $P$-value along with some meta data:

```{r}
head(associated_seqs)
```


## 2. Find Associated Clones

The next step is to use the `findAssociatedClones()` function to search across samples for all clones within a neighborhood of each associated sequence identified in the previous step. 

```{r}
# output directory for current step
dir_nbds <- file.path(data_dir, "assoc_seq_nbds")

# Identify neighborhood around each associated sequence
findAssociatedClones(
  file_list = input_files, input_type = "rds", group_ids = group_labels,
  seq_col = "CloneSeq", dist_type = "levenshtein",
  assoc_seqs = associated_seqs$ReceptorSeq,
  min_seq_length = NULL, drop_matches = NULL,
  output_dir = dir_nbds)
```

For each associated sequence, its neighborhood consists of all clones (from all samples) within a specified distance of the associated sequence. The distance threshold and type of distance metric used to determine the neighborhoods can be adjusted via the `dist_type` and `nbd_radius` arguments (by default, each neighborhood is defined based on a maximum Hamming distance of 1).

The associated sequences to consider are specified via the `assoc_seqs` argument, which takes a character vector. In the above example, we have used all of the associated sequences obtained during step 1 since here we only have one such sequence to consider. Depending on the number of associated sequences resulting from the filter settings used in step 1, we may not wish to consider all of the sequences returned by `findAssociatedSeqs()`. In this case, we can simply pass a vector containing the desired subset of sequences to the `assoc_seqs` argument. The associated sequences from step 1 are automatically ordered by Fisher's exact test $P$-value so that, e.g., the 10 associated sequences with the lowest $P$-values can be easily referenced.

Note that this function does not return any output; instead, it writes the data for each neighborhood to a separate file in `output_dir`, resulting in one file per associated sequence. By default, each file is written as a csv file (this can be changed via the `output_type` argument).

```{r}
# Intermediate files created during this step
nbd_files <- file.path(dir_nbds, list.files(dir_nbds))
nbd_files
```



## 3. Build Associated Cluster Network

Next, we use the `buildAssociatedClusterNetwork` function to combine all of the clones obtained in the previous step and perform network analysis and clustering. 

The character vector provided to the `file_list` argument should contain paths to the files created by `findAssociatedClones()` in the previous step.

```{r}
# Combine neighborhoods and perform network analysis
all_clusters <- buildAssociatedClusterNetwork(
  file_list = nbd_files,
  seq_col = "CloneSeq", dist_type = "levenshtein", size_nodes_by = 1.5,
  output_dir = file.path(data_dir, "assoc_clusters"))
```

If desired, we can then perform more detailed network analysis for particular clusters of interest.

```{r}
# focus on a particular cluster
buildRepSeqNetwork(
  data = all_clusters$node_data[all_clusters$node_data$cluster_id == 3, ],
  seq_col = "CloneSeq", color_nodes_by = "CloneSeq", size_nodes_by = 2,
  output_dir = NULL, output_name = "Cluster 3")
```


## 4. (Optional) K-means on Atchley factor encoding

**NOTE: This step applies to TCR CDR3 amino acid sequences only**

As an additional step in the analysis, we can take the TCR sequences from the full network in step 3 and use a deep learning algorithm with a trained encoder to encode each TCR sequence as a 30-dimensional numeric vector based on the Atchley-factor representations of its amino acids. This allows us to perform $K$-means clustering on the TCR sequences based on their numerically encoded values. 

We can then profile each sample based on how its TCRs are distributed among the $K$-means clusters: We compute the fraction of the sample's unique TCR sequences that belong to each cluster, yielding a $K$-dimensional vector representing the profile for the sample. We can then use heatmaps to compare these profiles across samples and to assess the correlation in profile between samples.

```{r, eval = FALSE}
atchley_results <- kmeansAtchley(
  data = all_clusters$node_data,
  amino_col = "CloneSeq", sample_col = "SampleID", group_col = "GroupID",
  k = 5, output_dir = file.path(data_dir, "assoc_clusters"), 
  return_output = TRUE)
```

The ultimate purpose of `kmeansAtchley()` is to produce the two heatmaps, which are generated using `gplots::heatmap.2()` and saved to pdf. The numerically-encoded TCR values and the $K$-means sample profiles will be returned if `return_output = TRUE`.