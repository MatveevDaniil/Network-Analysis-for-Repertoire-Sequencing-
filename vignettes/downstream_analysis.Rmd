---
title: "Downstream Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Downstream Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center", 
  out.width = "100%",
  fig.width = 9, fig.height = 7
)
```


The output returned by `buildRepSeqNetwork()` and other top-level `NAIR` functions can be used to facilitate further downstream analysis. Some common cases follow.


### Load Data

For demonstration purposes, we simulate some toy data using built-in package functions.

```{r }
library(NAIR)
dir_out <- tempdir()
toy_data <- simulateToyData()
names(toy_data)[names(toy_data) == "SampleID"] <- "TimePoint"
head(toy_data)
```


### Downstream Customization of Plots

While the arguments of `buildRepSeqNetwork()` and other top-level `NAIR` functions allow for substantial customization of the plots generated, you may occasionally find yourself wanting full control over all aspects of a plot. Or you may want to modify a plot further downstream based on the initial analysis.

All plots generated by `buildRepSeqNetwork()` and other top-level `NAIR` functions are included in the output as `ggraph` objects. These are special kinds of `ggplot` objects, and their properties can be manipulated like any plot created with `ggplot()` using the same functions from the `ggplot2` package.

For example, suppose we have previously executed the following code, which returns a list of network objects including the plot seen below:
```{r}
output <- buildRepSeqNetwork(toy_data, "CloneSeq", node_stats = TRUE,
                             output_dir = NULL)
```

We may later wish to modify the plot. Suppose, for example, that we want to remove the plot title/subtitle, adjust the node size, color the nodes using the `CloneCount` variable and change the color palette. We can do so using standard `ggplot2` functions (along with the `geom_node_point` function from the `ggraph` package) as follows:

```{r}
library(ggraph)
output$plots[[1]] + 
  labs(title = NULL, subtitle = NULL) +  
  ggraph::geom_node_point(
    aes(color = output$node_data$CloneCount), 
    size = 1.25) +
  guides(color = guide_legend(title = "Clone Count")) + 
  scale_color_gradient(low = "pink", high = "purple4")  
```

### Generating New Plots

Modifying the plot returned by `buildRepSeqNetwork()` has its limits; for example, if our plot already has its nodes colored using a continuous variable, so it isn't possible to change this to a discrete variable using the previous approach. 

For greater control, we can generate new plots as needed using the `igraph` object included in the output of `buildRepSeqNetwork()`. 

#### `plotNetworkGraph`: Generate a single plot

To generate a single plot, the `igraph` object can be passed to `plotNetworkGraph()`; this function is a wrapper to the `ggraph` function, so a plot can also be generated directly using `ggraph()` for users experienced with `ggplot2`. 

Here we generate a new plot, coloring the nodes using the `TimePoint` variable, and manually specifying a color palette using the `scale_color_manual` function from the `ggplot2` package:

```{r}
plotNetworkGraph(igraph = output$igraph,
                 color_nodes_by = output$node_data$TimePoint,
                 color_title = "Time Point",
                 size_nodes_by = 1) +
  scale_color_manual(values = c("deepskyblue", "red2"))
```

The arguments of `plotNetworkGraph` are largely identical to the visualization customization arguments of `buildRepSeqNetwork()` detailed in [this vignette](network_visualization.html). The primary difference is that the `color_nodes_by` and `size_nodes_by` arguments, rather than taking column references, should be used to pass the referenced column vectors themselves, as seen in the above example.

#### `generateNetworkGraphPlots`: Generate multiple plots

The `generateNetworkGraphPlots` function can be used to generate multiple plots in the same fashion supported by `buildRepSeqNetwork()`, where supplying a vector of multiple column references to the `color_nodes_by` argument will generate one plot for each variable used to encode the node colors: 

```{r}
plot_list <- generateNetworkGraphPlots(
  igraph = output$igraph, data = output$node_data,
  color_nodes_by = c("CloneCount", "TimePoint"), size_nodes_by = 1)
```

Here the `color_nodes_by` argument takes column references as per `buildRepSeqNetwork()` rather than a vector as per `plotNetworkGraph`. The function returns a list containing one item for each plot.


### Saving Plots to a pdf

Multiple plots generated by `buildRepSeqNetwork()` or `generateNetworkGraphPlots()` can be conveniently saved to a single pdf by feeding the list of plots to `saveNetworkPlots`:

```{r}
saveNetworkPlots(output$plots, outfile = file.path(dir_out, "plots.pdf"))
```



### Matching Output Data to Input Data

If one wishes to match rows of the input data to rows of the node-level meta data returned by `buildRepSeqNetwork()`, this can be done by matching the row names, since these are preserved in the output data: 

```{r}
head(output$node_data[ , c("CloneSeq", "CloneCount")])
head(toy_data[rownames(output$node_data) , c("CloneSeq", "CloneCount")])
```



### Generating network objects

The `generateNetworkObjects` function can be used as a lightweight version of `buildRepSeqNetwork()`; it does not include input filtering, computation of network properties, generation of plots, or saving of results, but simply returns a list containing the igraph, adjacency matrix and node-level meta data.

```{r}
network <- generateNetworkObjects(toy_data, "CloneSeq")
```



### Computing Network Properties

Node-level network properties can be added to the node-level meta data after the network has already been built by passing the data and the `igraph` network object to the `addNodeNetworkStats` function:

```{r}
# Network generated without node-level stats
output <- buildRepSeqNetwork(toy_data, "CloneSeq", print_plots = FALSE,
                             output_dir = NULL)

# Variables present in node-level meta data
head(output$node_data)

# Add network stats to node-level meta data 
output$node_data <- addNodeNetworkStats(output$node_data,
                                        net = output$igraph,
                                        stats_to_include = "all")

# Variables now include node-level network stats:
head(output$node_data)
```

Cluster-level properties can be obtained by passing the node-level meta data and the adjacency matrix to the `getClusterStats` function:

```{r, eval = FALSE}
output$cluster_data <- 
  getClusterStats(data = output$node_data,
                  adjacency_matrix = output$adjacency_matrix,
                  seq_col = "CloneSeq", count_col = "CloneCount")
head(output$cluster_data)
```


### Saving Network Objects

If the list of network objects returned by `buildRepSeqNetwork` and other top-level `NAIR` functions is modified during downstream analysis, it can be conveniently re-saved by passing it to the `saveNetwork` function:

```{r}
saveNetwork(net = output, output_dir = dir_out, output_type = "individual")
```

By default, each object in the list is saved as a separate, uncompressed file. Use `output_type = "rda"` or `output_type = "rds"` to save the entire list of network objects as a compressed .rda or .rds file (in addition to a pdf file for the plots).



### Generating `igraph` Network From Adjacency Matrix

It is not strictly necessary to save the `igraph` object for a network as long as one has the adjacency matrix returned by `buildRepSeqNetwork()`. Regenerating the `igraph` object from the adjacency matrix is extremely fast, and can be done using the `generateNetworkFromAdjacencyMat` function, which is a convenient wrapper to the `igraph` functions `graph_from_adjacency_matrix`, `simplify` and `as.undirected`. 

```{r}
# create igraph from adjacency matrix
network <- generateNetworkFromAdjacencyMat(output$adjacency_matrix)
```

This object can then be passed to `plotNetworkGraph()` or other functions that act on `igraph` network objects.


### Computing Adjacency Matrices

If one wishes to regenerate the adjacency matrix for a network, this can be done by passing the column of the node-level meta data containing the TCR/BCR sequences to the `sparseAdjacencyMatFromSeqs` function. This can be considerably faster than using `buildRepSeqNetwork()` again with the original input data: assuming `buildRepSeqNetwork()` was originally called with the default setting of `drop_isolated_nodes = TRUE`, then depending on the number of nodes dropped, the number of pairwise distances that must be recomputed could potentially be far less than the number originally computed. 

```{r, eval = FALSE}
adjacency_matrix <- sparseAdjacencyMatFromSeqs(output$node_data$CloneSeq)
```

This function is also useful in general as a computationally fast and memory efficient tool for generating graph adjacency matrices based on the Hamming or Levenshtein distance, as the matrices are computed in C++ as sparse integer matrices and returned in `R` as sparse matrices of class `dgCMatrix` from the `Matrix` package.
