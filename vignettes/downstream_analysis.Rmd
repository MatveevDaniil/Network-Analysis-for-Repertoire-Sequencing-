---
title: "Downstream Analysis"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Downstream Analysis}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center", 
  out.width = "100%",
  fig.width = 9, fig.height = 7
)
```


The output returned by `buildRepSeqNetwork()` and other top-level `NAIR` functions can be used to facilitate further downstream analysis. Some common cases follow.


### Load Data

For demonstration purposes, we load a  [public data set](https://www.10xgenomics.com/resources/datasets/pbm-cs-of-a-healthy-donor-v-1-1-1-standard-3-1-0) hosted at 10xgenomics.com using Bioconductor.

```{r }
library(ggplot2)
dir_out <- tempdir()
if (!require("BiocFileCache", quietly = TRUE)) { 
  if (!require("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
  }
  BiocManager::install("BiocFileCache", update = FALSE) 
}
library(NAIR)
library(BiocFileCache)
bfc <- BiocFileCache(ask = FALSE)
data_file <- bfcrpath(bfc, file.path(
  "http://cf.10xgenomics.com/samples/cell-vdj/3.1.0",
  "vdj_v1_hs_pbmc3/vdj_v1_hs_pbmc3_t_filtered_contig_annotations.csv"))
tcr_data <- read.csv(data_file, stringsAsFactors = FALSE)
head(tcr_data)
```

Each row corresponds to a TCR sequence from a single cell, with the cell ID contained in the first column, `barcode`. Sequences from both the beta and alpha chains are present, as denoted by the values `TRA` and `TRB` in the column `chain`. We consider the beta-chain CDR3 amino acid sequences.

```{r}
# Subset rows for valid beta-chain CDR3 amino acid sequences
tcr_data <- tcr_data[tcr_data$chain == "TRB" & tcr_data$cdr3 != "None", ]
```


### Downstream Customization of Plots

While the arguments of `buildRepSeqNetwork()` and other top-level `NAIR` functions allow for substantial customization of the plots generated, you may occasionally find yourself wanting full control over all aspects of a plot. Or you may want to modify a plot further downstream based on the initial analysis.

All plots generated by `buildRepSeqNetwork()` and other top-level `NAIR` functions are included in the output as `ggraph` objects. These are special kinds of `ggplot` objects, and their properties can be manipulated like any plot created with `ggplot()` using the same functions from the `ggplot2` package.

For example, suppose we have previously run the following:
```{r}
output <- buildRepSeqNetwork(tcr_data, "cdr3", node_stats = TRUE, 
                             stats_to_include = "all",
                             output_dir = NULL)
```
Now, suppose we want to remove the plot title/subtitle, adjust the node size, color the nodes using the `umis` variable and change the color palette. We can do so using standard `ggplot2` functions (along with the `geom_node_point` function from the `ggraph` package) as follows:

```{r, eval = FALSE}
output$plots[[1]] + # modify plot from output
  labs(title = NULL, subtitle = NULL) +  # remove title/subtitle
  ggraph::geom_node_point(  # color nodes by coreness and set node size to 1
    aes(color = output$node_data$umis), size = 1) +
  guides(color = guide_legend(title = "UMIs")) + # change color legend title
  scale_color_gradient(low = "pink", high = "purple4")  # change color gradient
```

### Generating New Plots

In addition to modifying plots returned by `buildRepSeqNetwork()`, we also can generate new ones from the `igraph` object included in its output.  This can be simpler when you want a plot that is sufficiently different from the one in your existing output. 

The `igraph` object can be passed to the `plotNetworkGraph` function in order to generate the plot; this function is a wrapper to the `ggraph` function, so a plot can also be generated directly using `ggraph()` for users experienced with `ggplot2`. The arguments of `plotNetworkGraph` are largely identical to the visualization customization arguments of `buildRepSeqNetwork()` detailed in [this vignette](network_visualization.html). The primary difference is that the `color_nodes_by` and `size_nodes_by` arguments, rather than accepting column references, accept the referenced column vectors themselves.

Here we generate a new plot, coloring the nodes using the `c_gene` variable, and manually specifying a color palette using the `scale_color_manual` function from the `ggplot2` package:

```{r}
plotNetworkGraph(igraph = output$igraph,
                 color_nodes_by = output$node_data$c_gene,
                 color_title = "C Gene",
                 size_nodes_by = 1) +
  scale_color_manual(values = c("grey", "deepskyblue", "red2"))
```

The `generateNetworkGraphPlots` function can be used to generate multiple plots in the same fashion supported by `buildRepSeqNetwork()`, where supplying a vector of multiple column references to the `color_nodes_by` argument will generate one plot for each variable used to encode the node colors: 

```{r}
generateNetworkGraphPlots(
  igraph = output$igraph, data = output$node_data, print_plots = TRUE,
  color_nodes_by = c("c_gene", "umis"))
```


Here the `color_nodes_by` argument takes column references as per `buildRepSeqNetwork()` rather than a vector as per `plotNetworkGraph`. The function returns a list containing one item for each plot.


### Saving Plots to a pdf

Multiple plots generated by `buildRepSeqNetwork()` or `generateNetworkGraphPlots()` can be conveniently saved to a single pdf by feeding the list of plots to `saveNetworkPlots`:
```{r}
saveNetworkPlots(output$plots, outfile = file.path(dir_out, "plots.pdf"))
```



### Matching Output Data to Input Data

If one wishes to match rows of the input data to rows of the node-level meta data returned by `buildRepSeqNetwork()`, this can be done by matching the row names, since these are preserved in the output data: 

```{r}
head(output$node_data[ , c("barcode", "cdr3")])
head(tcr_data[rownames(output$node_data) , c("barcode", "cdr3")])

```



### Generating network objects

The `generateNetworkObjects` function can be used as a lightweight version of `buildRepSeqNetwork()`; it does not include input filtering, computation of network properties, generation of plots, or saving of results, but simply returns a list containing the igraph, adjacency matrix and node-level meta data.

```{r}
network <- generateNetworkObjects(tcr_data, "cdr3")
```



### Computing Network Properties

Node-level network properties can be computed and added to the node-level meta data using the `igraph` network object:
```{r, eval = FALSE}
output <- buildRepSeqNetwork(tcr_data, "cdr3", print_plots = FALSE,
                             output_dir = NULL)

output$node_data <- addNodeNetworkStats(output$node_data,
                                        net = output$igraph,
                                        stats_to_include = "all")
```

Cluster-level properties can be computed using the node-level meta data and the adjacency matrix:

```{r, eval = FALSE}
output$cluster_data <- 
  getClusterStats(data = output$node_data,
                  adjacency_matrix = output$adjacency_matrix,
                  seq_col = "cdr3")
```


### Saving Network Objects

If the list of network objects returned by `buildRepSeqNetwork` and other top-level `NAIR` functions is modified during downstream analysis, it can be conveniently re-saved by passing it to the `saveNetwork` function:

```{r}
saveNetwork(net = output, output_dir = dir_out, output_type = "individual")
```

By default, each object in the list is saved as a separate, uncompressed file. Use `output_type = "rda"` or `output_type = "rds"` to save the entire list of network objects as a compressed .rda or .rds file (in addition to a pdf file for the plots).



### Generating `igraph` Network From Adjacency Matrix

It is not strictly necessary to save the `igraph` object for a network as long as one has the adjacency matrix returned by `buildRepSeqNetwork()`. Regenerating the `igraph` object from the adjacency matrix is extremely fast, and can be done using the `generateNetworkFromAdjacencyMat` function, which is a convenient wrapper to the `igraph` functions `graph_from_adjacency_matrix`, `simplify` and `as.undirected`. 

```{r}
network <- generateNetworkFromAdjacencyMat(output$adjacency_matrix)
```

This object can then be passed to `plotNetworkGraph()` or other functions that act on `igraph` network objects.


### Computing Adjacency Matrices

If one wishes to regenerate the adjacency matrix for a network, this can be done by passing the column of the node-level meta data containing the TCR/BCR sequences to the `sparseAdjacencyMatFromSeqs` function. This can be considerably faster than using `buildRepSeqNetwork()` again with the original input data: assuming `buildRepSeqNetwork()` was originally called with the default setting of `drop_isolated_nodes = TRUE`, then depending on the number of nodes dropped, the number of pairwise distances that must be recomputed could potentially be far less than the number originally computed. 

```{r, eval = FALSE}
adjacency_matrix <- sparseAdjacencyMatFromSeqs(output$node_data$cdr3)
```

This function is also useful in general as a computationally fast and memory efficient tool for generating graph adjacency matrices based on the Hamming or Levenshtein distance, as the matrices are computed in C++ as sparse integer matrices and returned in `R` as sparse matrices of class `dgCMatrix` from the `Matrix` package.
